

## js数据类型和数据机制
- 基本数据类型：String, Number, Boolean, Null, Undefined, (+Symbol)
- 引用数据类型：Object

- 内存空间：
    - 堆空间：会有一个16进制的内存地址，与栈空间中某个变量关联。js通过操作这个对象来操作堆空间的这个对象。
    - 栈空间：先进后出，类比水桶，只能从栈顶插入数据，称为入栈；出栈的顺序也是从栈顶开始，最后进入的数据最先删除，称为出栈。

- 基本数据类型值存储在栈空间中，赋值的过程是将变量和值进行一个关联。
- 引用数据类型存储在堆空间中，我们操作对象其实操作的是该对象的引用，而引用是保存在栈内存中的一个内存地址，该地址与堆内存中的值相关联。



## 垃圾回收机制

### 什么是垃圾回收？
javascript引擎定期找出不在使用的变量，释放其所占用的内存。


内存管理是由javascript引擎自动执行的，是不可见的。周期性的执行释放操作。

### 垃圾回收机制的优势与缺点
- 优势：可以大幅度的简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。
- 缺点：意味着程序员将无法掌握内存。javascript没有暴露任何关于内存的api。我们无法强迫其进行垃圾回收，更无法干预内存管理。


### 垃圾回收策略，有2种
- 1、引用计数
    - 跟踪记录每个值被引用的次数，如果值的引用次数是0，就表示这个值不再用到了，因此将这块内存释放。
- 原理
    - 每次引用+1，被释放时-1，当这个值的引用次数变成0的时候，就可以将其内存空间回收。
- 举个栗子看一下
```
var obj1 = {a:10}   //{a:10}的引用次数+1
var obj2 = {a:10}   //{a:10}的引用次数+1
obj1={} //obj1对{a:10}引用次数-1
obj1=null   //obj1对{a:10}引用次数为0
obj2=null   //obj2对{a:10}引用次数为0
```
1、声明一个变量并将一个引用类型的值赋值给这个变量，该引用类型的值引用次数是1
2、同一个值又被赋值给另一个变量，这个引用类型值的引用次数+1
3、当包含这个引用类型值的变量又被赋值给另一个值了，那么该引用类型引用次数-1
4、引用次数变成0时，即需要将该变量销毁，释放内存。

循环引用会导致引用计数产生bug
```
function fn(){
    var obj1 = {}
    var obj2 = {}
    obj1.a = obj2   // 引用+1
    obj2.b = obj1   // 引用+1
}
```


- 2、标记清除
    - 当变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。最后，垃圾回收器完成内存清除工作，销毁并回收那些被标记为“离开环境”的值所占用的内存空间。

- 执行环境
    - 分为全局执行环境和局部执行环境
        - 全局执行环境：最外围的一个执行环境。在web浏览器中，与全局执行环境关联的变量对象是windows对象；而Node中，全局执行环境是global.
        - 局部执行环境：每个函数都有自己的执行环境。当执行流进入一个函数时，函数环境会被推入一个环境栈中；而在函数执行后，栈将其环境弹出，将控制权返回给之前的执行环境。

举个栗子：
```
function foo(){
    var a = 10  // 变量a被标记进入环境
    var b = 'hello' // 变量b被标记进入环境
}
foo()   // 执行完毕，a和b被标记离开环境，内存被回收
```


## V8内存管理机制(难点)

### 为甚么限制内存？
- 最初为浏览器而设计，不太可能遇到大量内存的使用场景。
- 因为单次执行垃圾回收执行的时间过长，所以要尽可能少的用到。


- V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。
- V8分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。

### 新生代和老生代的算法
- 1、在新生代垃圾回收的过程中，当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理。
- 2、在From空间和To空间进行反转的过程中，如果To空间汇总的使用量已经超过了25%，那么将From中的对象直接晋升到老生带内存空间中，这叫做内存空间的晋升。

新生代空间用来存放存活时间较短的对象，老生带空间用来存放存活时间较长的对象。


老生带内存空间是一个连续的结构，且老生代内存空间释放空间有标记清除和标记合并。
新生代内存空间分为From和To两部分,他清除垃圾的方式是空间反转的方式。

标记合并算法的作用是：在连续的内存空间中存在A、B、C、D四个部分，如果A和C被标记清除了，那么B、D就是不连续的。此时标记合并的方法是：把标记清楚的部分放在空间的左边，把没有被标记的放在内存的右边，以解决内存空间不连续的问题。




